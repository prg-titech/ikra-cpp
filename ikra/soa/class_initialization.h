#ifndef SOA_CLASS_INITIALIZATION_H
#define SOA_CLASS_INITIALIZATION_H

#include "soa/util.h"

#define IKRA_INITIALIZE_CLASS \
/* This class is used to calculate field offsets inside a SOA class. For every
 * field declaration, a new class specialization will be generated using
 * macro expansion. "N" is index of the field and "value" is the offset of
 * that field in bytes. "DummyT" is required only because full template
 * specializations are not allowed for nested classes in C++. */ \
template<uint32_t N, typename DummyT = void> \
struct OffsetCounter { \
  /* Used by ObjectSize_. Indicates that the no more fields are available. */ \
  static const bool kReachedGeneralCase = true; \
}; \
\
/* Base case for first field declaration. */ \
template<typename DummyT> \
struct OffsetCounter<0, DummyT> { \
  /* Offset of field 0 in bytes. */ \
  static const uint32_t value = 0; \
\
  /* Used by ObjectSize_. Indicates that this template instantiation was
  * generated by a field declaration. */ \
  static const bool kIsSpecialization = true; \
}; \
\
/* This class calculates object size and number of fields.
 * Note: This class cannot be used from within a SOA class. Only when all
 * fields are defined, members of this class may be accessed. */ \
template<uint32_t N> \
struct ObjectSize_ { \
 private: \
  template<int N0 = N> \
  static typename std::enable_if< \
      OffsetCounter<N0>::kIsSpecialization, \
      std::integral_constant<int, ObjectSize_<N0 + 1>::kNumFields>>::type \
  sfinae_dummy() {} \
\
  template<int N0 = N> \
  static typename std::enable_if< \
      OffsetCounter<N0>::kReachedGeneralCase, \
      std::integral_constant<int, N0 - 1>>::type \
  sfinae_dummy() {} \
\
 public: \
  static const int kNumFields = decltype(sfinae_dummy())::value; \
  static const uintptr_t value = OffsetCounter<kNumFields>::value; \
}; \
\
/* Alias for simplier access of object size: MyClass::ObjectSize::value. */ \
using ObjectSize = ObjectSize_<0>; \
/* Function that returns a reference to the storage buffer.
 * Will be inlined. Pointer dereference will be optimized out. */ \
__ikra_host_device__ static Storage& storage(); \
__ikra_host_device__ static constexpr char* storage_buffer(); \
\
static const uint32_t kCounterFirstIndex = __COUNTER__;

#endif  // SOA_CLASS_INITIALIZATION_H
